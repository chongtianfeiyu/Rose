#include "global.hpp"
#include "game_config.hpp"
#include "filesystem.hpp"
#include "language.hpp"
#include "loadscreen.hpp"
#include "editor.hpp"
#include "wml_exception.hpp"
#include "gettext.hpp"
#include "gui/dialogs/message.hpp"
#include "serialization/parser.hpp"
#include "formula_string_utils.hpp"
#include <SDL_filesystem.h>
#include <SDL_image.h>
#include "sln.hpp"

#include "animation.hpp"
#include "builder.hpp"

#include <iomanip>
#include <boost/foreach.hpp>
using namespace std::placeholders;

#include <opencv2/imgproc.hpp>

const std::string studio_guid = "3641E31E-36BF-4E03-8879-DE33ADC07D68";

std::string extract_android_lib_stem(const std::string& lib)
{
	size_t npos = lib.find("lib");
	if (npos != 0) {
		return null_str;
	}
	npos = lib.find(".so");
	if (npos == std::string::npos || npos + 3 != lib.size()) {
		return null_str;
	}
	return lib.substr(3, lib.size() - 3 - 3);
}

// base os_windows/os_ios/os_android
static const char* os_names[] = {
	"windows",
	"ios",
	"android"
};

void tapp_capabilities::generate2(std::stringstream& ss, const std::string& prefix) const
{
	VALIDATE(bundle_id.valid(), null_str);

	ss.str("");
	ss << "#\n";
	ss << "# NOTE: it is generated by rose studio, don't edit yourself.\n";
	ss << "#\n";
	ss << "\n";

	if (app != bundle_id.node(2)) {
		ss << prefix << "app = " << app << "\n";
	}
	ss << prefix << "bundle_id = \"" << bundle_id.id() << "\"\n";
	if (ble) {
		ss << prefix << "ble = yes\n";
	}
	if (wifi) {
		ss << prefix << "wifi = yes\n";
	}
	if (bootup) {
		ss << prefix << "bootup = yes\n";
	}

	if (tdomains.size() > 1) {
		std::stringstream extra_textdomain;
		const std::string app_lib = app + "-lib";
		for (std::set<std::string>::const_iterator it = tdomains.begin(); it != tdomains.end(); ++ it) {
			const std::string& domain = *it;
			if (domain != app_lib) {
				if (!extra_textdomain.str().empty()) {
					extra_textdomain << ", ";
				}
				extra_textdomain << domain;
			}
		}
		ss << prefix << "extra_textdomain = " << extra_textdomain.str() << "\n";
	}

	if (path_ != "..") {
		ss << prefix << "path = " << path_ << "\n";
	}

	for (std::map<int, tos>::const_iterator it = os_special.begin(); it != os_special.end(); ++ it) {
		const tos& os = it->second;
		ss << "\n";

		ss << prefix << "[" << os_names[it->first] << "]\n";

		if (!os.extra_libs.empty()) {
			ss << prefix << "\textra_libs = " << utils::join(os.extra_libs) << "\n";
		}
		if (!os.extra_LOCAL_CFLAGS.empty()) {
			ss << prefix << "\textra_LOCAL_CFLAGS = " << utils::join(os.extra_LOCAL_CFLAGS) << "\n";
		}
		if (!os.extra_external_mks.empty()) {
			ss << prefix << "\textra_external_mks = " << utils::join(os.extra_external_mks) << "\n";
		}

		ss << prefix << "[/" << os_names[it->first] << "]\n";
	}
}

bool is_apps_kit(const std::string& res_folder)
{
	// 1. resource directory
	const std::string APPS_RES = "apps-res";
	size_t pos = res_folder.find(APPS_RES);
	if (pos == std::string::npos || pos + APPS_RES.size() != res_folder.size()) {
		return false;
	}

	// 2. code directory
	const std::string& src_folder = game_config::apps_src_path;
	const std::string APPS_SRC = "apps-src";
	pos = src_folder.find(APPS_SRC);
	if (pos == std::string::npos || pos + APPS_SRC.size() != src_folder.size()) {
		return false;
	}

	// 3. apps.sln
	if (!apps_sln::apps_in(src_folder + "/apps").size()) {
		return false;
	}

	return true;
}

// private app will not in <apps-res>/absolute/apps.cfg
bool is_private_app(const std::string& app)
{
	static std::set<std::string> private_apps;
	if (private_apps.empty()) {
		private_apps.insert("studio");
	}

	return private_apps.find(app) != private_apps.end();
}

// reserve app can not be removed.
bool is_reserve_app(const std::string& app)
{
	static std::set<std::string> reserve_apps;
	if (reserve_apps.empty()) {
		// reserve_apps.insert("aismart");
		reserve_apps.insert("editor");
		reserve_apps.insert("iaccess");
		reserve_apps.insert("kdesktop");
		reserve_apps.insert("kingdom");
		reserve_apps.insert("iaccess");
		reserve_apps.insert("launcher");
		reserve_apps.insert("studio");
	}

	return reserve_apps.find(app) != reserve_apps.end();
}

// reserve2_app can not be new
bool is_reserve2_app(const std::string& app)
{
	static std::set<std::string> reserve2_apps;
	if (reserve2_apps.empty()) {
		// below are directory name at <apps-src>/apps.
		reserve2_apps.insert("external");
		reserve2_apps.insert("projectfiles");

		// gradle is directory name at projectfiles/android.
		reserve2_apps.insert("gradle");

	}

	return reserve2_apps.find(app) != reserve2_apps.end();
}

bool is_reserve_aplt(const std::string& lua_bundleid)
{
	static std::set<std::string> reserve_aplts;
	if (reserve_aplts.empty()) {
		reserve_aplts.insert("aplt_leagor_blesmart");
		reserve_aplts.insert("aplt_leagor_iaccess");
	}

	return reserve_aplts.count(lua_bundleid) != 0;
}

bool check_res_folder(const std::string& folder)
{
	std::stringstream ss;
	
	// <wok>\data\_main.cfg
	ss << folder << "\\data\\_main.cfg";
	if (!file_exists(ss.str())) {
		return false;
	}

	return true;
}

bool check_apps_src_folder(const std::string& folder)
{
	std::stringstream ss;
	
	ss << folder << "/apps/projectfiles/vc/apps.sln";
	if (!file_exists(ss.str())) {
		return false;
	}

	return true;
}

struct tcopy_cookie
{
	tcopy_cookie(const std::string& dir)
		: current_path(dir)
	{
		char c = current_path.at(current_path.size() - 1);
		if (c == '\\' || c == '/') {
			current_path.erase(current_path.size() - 1);
		}
	}

	bool cb_copy_cookie(const std::string& dir, const SDL_dirent2* dirent);

	std::string current_path;
};

bool tcopy_cookie::cb_copy_cookie(const std::string& dir, const SDL_dirent2* dirent)
{
	if (SDL_DIRENT_DIR(dirent->mode)) {
		tcopy_cookie ccp2(current_path + "/" + dirent->name);
		const std::string cookie_cki = "__cookie.cki";
		{
			tfile lock(ccp2.current_path + "/" + cookie_cki, GENERIC_WRITE, CREATE_ALWAYS);
		}

		if (!walk_dir(ccp2.current_path, false, std::bind(&tcopy_cookie::cb_copy_cookie, &ccp2, _1, _2))) {
			return false;
		}
	}
	return true;
}

bool is_studio_app(const std::string& app)
{
	return app == "studio";
}

int file_delete_line(tfile& file, const char* ptr, int& fsize)
{
	// start
	int start = ptr - file.data;
	while (file.data[start] != '\r' && file.data[start] != '\n' && start > 0) {
		start --;
	}
	if (file.data[start] == '\r' || file.data[start] == '\n') {
		start ++;
	}

	int stop = ptr - file.data;
	while (file.data[stop] != '\r' && file.data[stop] != '\n' && stop < fsize) {
		stop ++;
	}
	while ((file.data[stop] == '\r' || file.data[stop] == '\n') && stop < fsize) {
		stop ++;
	}
	fsize = file.replace_span(start, stop - start, NULL, 0, fsize);

	return start;
}



const std::string tapp_copier::windows_prj_alias = "windows_prj";
const std::string tapp_copier::android_prj_alias = "android_prj";
const std::string tapp_copier::ios_prj_alias = "ios_prj";
const std::string tapp_copier::kos_prj_alias = "kos_prj";
const std::string tapp_copier::app_windows_prj_alias = "app_windows_prj";
const std::string tapp_copier::app_android_prj_alias = "app_android_prj";
const std::string tapp_copier::app_ios_prj_alias = "app_ios_prj";
const std::string tapp_copier::app_kos_prj_alias = "app_kos_prj";

tapp_copier::tapp_copier(const config& cfg, const std::string& _app)
	: tapp_capabilities(cfg)
{
	if (app.empty()) {
		app = _app;
	}
	if (!bundle_id.valid()) {
		VALIDATE(!app.empty(), null_str);
		bundle_id.reset("com.leagor." + app);
	}
	VALIDATE(bundle_id.valid(), null_str);
	if (app.empty()) {
		app = bundle_id.node(2);
	}

	tdomains.insert(app + "-lib");

	std::vector<std::string> extra_tdomains = utils::split(cfg["extra_textdomain"].str());
	for (std::vector<std::string>::const_iterator it = extra_tdomains.begin(); it != extra_tdomains.end(); ++ it) {
		tdomains.insert(*it);
	}
}

void tapp_copier::app_complete_paths(std::map<std::string, std::string>& paths) const
{
	VALIDATE(!app.empty() && !paths.empty(), null_str);

	const std::string& res_path = ::alias_2_path(paths, ttask::res_alias);
	const std::string& src2_path = ::alias_2_path(paths, ttask::src2_alias);

	// app_res/app_src maybe overlay be *.cfg.
	VALIDATE(paths.find(ttask::app_res_alias) == paths.end(), null_str);
	VALIDATE(paths.find(ttask::app_src2_alias) == paths.end(), null_str);
	VALIDATE(paths.find(ttask::app_src_alias) == paths.end(), null_str);

	std::string app_res_path = res_path + "/" + path_;
	std::string app_src2_path = res_path + "/" + path_;
	if (is_studio_app(app)) {
		app_res_path += "/apps-res";
		app_src2_path += "/apps-src/apps";
	} else {
		app_res_path += "/" + app + "-res";
		app_src2_path += "/" + app + "-src/" + app;
	}
	app_res_path = utils::normalize_path(app_res_path);
	app_src2_path = utils::normalize_path(app_src2_path);

	VALIDATE(res_path != app_res_path && src2_path != app_src2_path, null_str);

	paths.insert(std::make_pair(ttask::app_res_alias, app_res_path));
	paths.insert(std::make_pair(ttask::app_src2_alias, app_src2_path));
	paths.insert(std::make_pair(ttask::app_src_alias, extract_directory(app_src2_path)));


	paths.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
	paths.insert(std::make_pair(app_windows_prj_alias, app_src2_path + "/projectfiles/vc"));
	paths.insert(std::make_pair(android_prj_alias, src2_path + "/projectfiles/android-prj"));
	paths.insert(std::make_pair(app_android_prj_alias, app_src2_path + "/projectfiles/android"));
	paths.insert(std::make_pair(ios_prj_alias, src2_path + "/projectfiles/ios-prj"));
	paths.insert(std::make_pair(app_ios_prj_alias, app_src2_path + "/projectfiles/Xcode-iOS"));
	paths.insert(std::make_pair(kos_prj_alias, src2_path + "/projectfiles/kos-prj"));
	paths.insert(std::make_pair(app_kos_prj_alias, app_src2_path + "/projectfiles/kos"));
}


std::set<std::string> app_include_directories(const std::string& app)
{
	std::set<std::string> include_directories = apps_sln::include_directories_in(app);
	std::set<std::string> extra_directories;
	const std::string app_include_dir = "../../" + app;
	for (std::set<std::string>::const_iterator it = include_directories.begin(); it != include_directories.end(); ++ it) {
		if (it->find(app_include_dir) == 0) {
			extra_directories.insert(*it);
		}
	}
	return extra_directories;
}

std::string app_version_from_settings_cfg(const std::string& app)
{
	VALIDATE(!app.empty(), null_str);

	if (app == game_config::app) {
		return game_config::version.str(true);
	}

	config_cache& cache = config_cache::instance();

	config cfg;
	cache.get_config(game_config::path + "/" + game_config::generate_app_dir(app) + "/settings.cfg", cfg);
	const config& app_settings_cfg = cfg.child("settings");
	if (!app_settings_cfg) {
		return game_config::rose_version.str(true);
	}
	if (!app_settings_cfg.has_attribute("version")) {
		return game_config::rose_version.str(true);
	}
	return app_settings_cfg["version"].str();
}

//
// why generate_ios_prj isn't class member? it will be called by both tios_kit and texporter.
//
static bool generate_ios_prj(const tapp_copier& copier, const std::string& app_res_path, const std::string& app_ios_prj_path)
{
	const std::string app_in_prj = "studio";

	if (app_in_prj != copier.app) {
		// rename <app_ios_prj>/studio to <app_ios_prj>/<app>
		SDL_RenameFile((app_ios_prj_path + "/" + app_in_prj).c_str(), copier.app.c_str());
	}

	// rename <app_ios_prj>/studio.xcodeproj to <app_ios_prj>/<app>.xcodeproj
	const std::string app_xcodeproj = copier.app + ".xcodeproj";
	if (app_in_prj != copier.app) {
		SDL_RenameFile((app_ios_prj_path + "/" + app_in_prj + ".xcodeproj").c_str(), app_xcodeproj.c_str());
	}

	// <app_ios_prj>/<app>.xcodeproj/project.pbxproj
	const std::string pbxproj_tmp = "project.pbxproj.tmp";
	std::string src = app_ios_prj_path + "/" + app_xcodeproj + "/" + pbxproj_tmp;
	std::string dst = app_ios_prj_path + "/" + app_xcodeproj + "/project.pbxproj";
	SDL_RenameFile(dst.c_str(), pbxproj_tmp.c_str());
	{
		std::vector<std::string> vstr;
		tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 4096 bytes.
		file.resize_data(fsize + 4096, fsize);
		file.data[fsize] = '\0';

		std::string prefix;
		const char* ptr = NULL;
		
		if (app_in_prj != copier.app) {
			// studio
			prefix = app_in_prj;
			ptr = strstr(file.data, prefix.c_str());
			while (ptr) {
				fsize = file.replace_span(ptr - file.data, prefix.size(), copier.app.c_str(), copier.app.size(), fsize);
				// replace next
				ptr = strstr(ptr, prefix.c_str());
			}
		}

		// PRODUCT_BUNDLE_IDENTIFIER, new bundle_id maybe include "studio", so place after replace app.
		prefix = "PRODUCT_BUNDLE_IDENTIFIER = ";
		ptr = strstr(file.data, prefix.c_str());
		while (ptr) {
			ptr = utils::skip_blank_characters(ptr + prefix.size());
			const char* ptr2 = utils::until_c_style_characters(ptr);
			fsize = file.replace_span(ptr - file.data, ptr2 - ptr, copier.bundle_id.id().c_str(), copier.bundle_id.size(), fsize);
			// replace next
			ptr = strstr(ptr, prefix.c_str());
		}

		//
		// insert extra include_directories
		//
		std::set<std::string> extra_directories = app_include_directories(copier.app);
		const std::string app_include_dir = "../../" + copier.app;
		prefix = app_include_dir;
		ptr = strstr(file.data, prefix.c_str());
		while (ptr) {
			ptr += prefix.size();
			std::stringstream ss;
			for (std::set<std::string>::const_iterator it = extra_directories.begin(); it != extra_directories.end(); ++ it) {
				const std::string& include = *it;
				if (include == app_include_dir) {
					continue;
				}
				ss << ",\n\t\t\t\t\t" << include; 
			}
			if (!ss.str().empty()) {
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
				ptr += ss.str().size();
			}
			ptr = strstr(ptr, prefix.c_str());
		}

		// write data to new file
		tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
		if (file2.valid()) {
			posix_fseek(file2.fp, 0);
			posix_fwrite(file2.fp, file.data, fsize);
		}
	}
	SDL_DeleteFiles(src.c_str());

	// <app_ios_prj>/Info.plist
	const std::string plist_tmp = "Info.plist.tmp";
	src = app_ios_prj_path + "/" + plist_tmp;
	dst = app_ios_prj_path + "/Info.plist";
	SDL_RenameFile(dst.c_str(), plist_tmp.c_str());
	{
		std::vector<std::string> vstr;
		tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 1024 bytes.
		file.resize_data(fsize + 1024, fsize);
		file.data[fsize] = '\0';

		std::string prefix;
		const char* ptr = NULL;

		// CFBundleDisplayName
		prefix = "<key>CFBundleDisplayName</key>";
		ptr = strstr(file.data, prefix.c_str());
		if (ptr) {
			prefix = "<string>";
			ptr = strstr(ptr, prefix.c_str());
			ptr += prefix.size();
			const char* ptr2 = strstr(ptr, "</string>");
			const std::string app_msgstr = game_config::get_app_msgstr(copier.app);
			fsize = file.replace_span(ptr - file.data, ptr2 - ptr, app_msgstr.c_str(), app_msgstr.size(), fsize);
		}

		// CFBundleShortVersionString
		prefix = "<key>CFBundleShortVersionString</key>";
		ptr = strstr(file.data, prefix.c_str());
		if (ptr) {
			prefix = "<string>";
			ptr = strstr(ptr, prefix.c_str());
			ptr += prefix.size();
			const char* ptr2 = strstr(ptr, "</string>");
			const std::string value = app_version_from_settings_cfg(copier.app);
			fsize = file.replace_span(ptr - file.data, ptr2 - ptr, value.c_str(), value.size(), fsize);
		}

		// write data to new file
		tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
		if (file2.valid()) {
			posix_fseek(file2.fp, 0);
			posix_fwrite(file2.fp, file.data, fsize);
		}
	}
	SDL_DeleteFiles(src.c_str());

	src = app_ios_prj_path + "/" + copier.app + "/" + app_in_prj + ".entitlements";
	SDL_DeleteFiles(src.c_str());

	// if (app_in_prj != copier.app) {
	{
		// Images.xcassets
		src = app_res_path + "/" + game_config::generate_app_dir(copier.app) + "/Images.xcassets";
		dst = app_ios_prj_path + "/" + copier.app;
		SDL_CopyFiles(src.c_str(), dst.c_str());

		const std::string dst_icon = dst + "/Images.xcassets/AppIcon.appiconset";
		// form Icon-167.png to misc Icon-xxx.png
		std::string full_file = game_config::path + "/" + game_config::generate_app_dir(copier.app) + "/images/assets/Icon-";
		std::stringstream file_ss;
		file_ss << full_file << "167.png";
		surface surf = image::get_image(file_ss.str());
		std::map<int, std::string> icons;
		icons.insert(std::make_pair(76, "Icon-76.png"));
		icons.insert(std::make_pair(120, "Icon-120.png"));
		icons.insert(std::make_pair(152, "Icon-152.png"));
		icons.insert(std::make_pair(167, "Icon-167.png"));
		icons.insert(std::make_pair(1024, "Icon-1024.png"));
		for (std::map<int, std::string>::const_iterator it = icons.begin(); it != icons.end(); ++ it) {
			const std::string dst = dst_icon + "/" + it->second;
			// VALIDATE(SDL_IsFile(dst.c_str()), null_str);
			file_ss.str("");
			file_ss << full_file << it->first << ".png";
			surface target_surf = image::get_image(file_ss.str());
			// now SDL_image doesn't support RGB.
			if (target_surf && target_surf->w == it->first && target_surf->h == it->first) {
				SDL_CopyFiles(file_ss.str().c_str(), dst.c_str());

			} else {
				surface scaled = scale_surface(surf, it->first, it->first);
				IMG_SavePNG(scaled, dst.c_str());
			}
		}

		const std::string launchimage_png = "LaunchImage-1242x2208.png";
		const std::string src = game_config::path + "/" + game_config::generate_app_dir(copier.app) + "/images/assets/" + launchimage_png;
		const std::string dst = app_ios_prj_path + "/" + launchimage_png;
		SDL_CopyFiles(src.c_str(), dst.c_str());
	}

	return true;
}

bool texporter::app_filter(const tsubtask& subtask, const std::string& src, bool dir)
{
	if (dir) {
		return true;
	}
	if (src.find("tensorflow.lib") != std::string::npos) {
		return false;
	}
	return true;
}

void texporter::app_complete_paths()
{
	copier_.app_complete_paths(paths_);
}

bool texporter::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	if (!generate_window_prj()) {
		return false;
	}

	if (!export_android_prj()) {
		return false;
	}

	if (!generate_kos_prj()) {
		return false;
	}

	if (!generate_ios_prj(copier_, alias_2_path(app_res_alias), alias_2_path(tapp_copier::app_ios_prj_alias))) {
		return false;
	}

	return true;
}

std::vector<std::pair<std::string, std::string> > texporter::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!copier_.app.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", copier_.app));
	ret.push_back(std::make_pair("<__bundle__>", copier_.bundle_id.id()));
	std::stringstream slash_bundle_ss;
	slash_bundle_ss << copier_.bundle_id.node(0) << "/" << copier_.bundle_id.node(1) << "/" << copier_.bundle_id.node(2);
	ret.push_back(std::make_pair("<__slash_bundle__>", slash_bundle_ss.str()));
	return ret;
}

bool texporter::generate_window_prj() const
{
	const std::string app_in_prj = "studio";
	bool is_apps = is_studio_app(copier_.app);

	const std::string& windows_prj_path = alias_2_path(tapp_copier::windows_prj_alias);
	const std::string& app_windows_prj_path = alias_2_path(tapp_copier::app_windows_prj_alias);

	// *.sln
	std::string src = windows_prj_path + "/apps.sln";
	std::string dst = app_windows_prj_path + "/" + (is_apps? "apps": copier_.app) + ".sln";
	std::string guid_str;
	{
		tfile file(app_windows_prj_path + "/" + copier_.app + ".vcxproj", GENERIC_READ, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		const char* start2 = file.data;
		if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
			start2 += BOM_LENGTH;
		}

		// studio
		std::string prefix = "<ProjectGuid>{";
		const char* ptr = strstr(start2, prefix.c_str());
		if (!ptr) {
			return false;
		}
		std::string postfix = "}</ProjectGuid>";
		ptr += prefix.size();
		const char* ptr2 = strstr(ptr, postfix.c_str());
		const int guid_size2 = 36;
		guid_str.assign(ptr, ptr2 - ptr);
		if (guid_str.size() != guid_size2) {
			return false;
		}
	}
	{
		tfile file(src,  GENERIC_READ, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';

		const char* start2 = file.data;
		if (utils::bom_magic_started((const uint8_t*)file.data, fsize)) {
			start2 += BOM_LENGTH;
		}

		// studio
		std::string prefix = app_in_prj;
		const char* ptr = NULL;
		if (prefix != copier_.app) {
			ptr = strstr(start2, prefix.c_str());
			while (ptr) {
				fsize = file.replace_span(ptr - file.data, prefix.size(), copier_.app.c_str(), copier_.app.size(), fsize);
				// replace next
				ptr = strstr(ptr, prefix.c_str());
			}
		}

		// guid of studio: 3641E31E-36BF-4E03-8879-DE33ADC07D68
		prefix = studio_guid;
		if (prefix != guid_str) {
			ptr = strstr(start2, prefix.c_str());
			while (ptr) {
				fsize = file.replace_span(ptr - file.data, prefix.size(), guid_str.c_str(), guid_str.size(), fsize);
				// replace next
				ptr = strstr(ptr, prefix.c_str());
			}
		}

		// write data to new file
		tfile file2(dst,  GENERIC_WRITE, CREATE_ALWAYS);
		if (file2.valid()) {
			posix_fseek(file2.fp, 0);
			posix_fwrite(file2.fp, file.data, fsize);
		}
	}

	// *.vcxproj.user
	src = windows_prj_path + "/" + app_in_prj + ".vcxproj.user";
	dst = app_windows_prj_path + "/" + copier_.app + ".vcxproj.user";

	std::vector<std::pair<std::string, std::string> > replaces;
	replaces.push_back(std::make_pair("apps-res", is_apps? "apps-res": copier_.app + "-res"));
	file_replace_string(src, dst, replaces);
	
	return true;
}

enum {CPP_FLAG = 1, CC_FLAG = 2, C_FLAG = 4};

bool texporter::collect_cpp_files2(const std::string& dir, const SDL_dirent2* dirent, uint32_t& flags) const
{
	bool isdir = SDL_DIRENT_DIR(dirent->mode);
	if (!isdir) {
		std::string name = utils::lowercase(dirent->name);
		if (!(flags & CPP_FLAG)) {
			size_t pos = name.rfind(".cpp");
			if (pos != std::string::npos && pos + 4 == name.size()) {
				flags |= CPP_FLAG;
			}
		}
		if (!(flags & CC_FLAG)) {
			size_t pos = name.rfind(".cc");
			if (pos != std::string::npos && pos + 3 == name.size()) {
				flags |= CC_FLAG;
			}
		}
		if (!(flags & C_FLAG)) {
			size_t pos = name.rfind(".c");
			if (pos != std::string::npos && pos + 2 == name.size()) {
				flags |= C_FLAG;
			}
		}
	}
	return true;
}

bool texporter::collect_cpp_files(const std::string& dir, const SDL_dirent2* dirent, std::map<std::string, uint32_t>& files) const
{
	bool isdir = SDL_DIRENT_DIR(dirent->mode);
	if (isdir) {
		uint32_t flags = 0;
		walk_dir(dir + "/" + dirent->name, false, std::bind(&texporter::collect_cpp_files2, this, _1, _2, std::ref(flags)));
		if (flags) {
			files.insert(std::make_pair(dir + "/" + dirent->name, flags));
		}
	}

	return true;
}

namespace utils {
extern const char* skip_blank_lines(const char* start, int lines);
}

std::pair<const char*, int> this_line_characters(const char* data_ptr, int data_len, const char* key_ptr, int key_len)
{
	VALIDATE(data_ptr <= key_ptr, null_str);
	VALIDATE(data_ptr + data_len >= key_ptr + key_len, null_str);
	VALIDATE(key_len > 0, null_str);

	const char* start = key_ptr;
	while (start != data_ptr) {
		start --;
		if (start[0] == '\r' || start[0] == '\n') {
			start ++;
			break;
		}
	}

	const char* end = key_ptr + key_len;
	while (end != data_ptr + data_len) {
		if (end[0] == '\r' || end[0] == '\n') {
			end ++;
			while (end != data_ptr + data_len && (end[0] == '\r' || end[0] == '\n')) {
				end ++;
			}
			break;
		}
		end ++;
	}
	return std::make_pair(start, end - start);
}

std::set<std::string> read_apps_from_settings_gradle(const std::string& filename)
{
	std::set<std::string> ret;

	tfile file(filename, GENERIC_READ, OPEN_EXISTING);
	VALIDATE(file.valid(), null_str);
	int fsize = file.read_2_data();
	if (fsize == 0) {
		return ret;
	}
	char* quotes_ptr = strstr(file.data, "include");
	if (quotes_ptr == nullptr) {
		return ret;
	}
	quotes_ptr = strchr(quotes_ptr, '\'');
	if (quotes_ptr == nullptr) {
		return ret;
	}

	char* nextline_ptr = strchr(quotes_ptr, '\n');
	if (nextline_ptr != nullptr) {
		nextline_ptr[0] = '\0';
	}
	std::vector<std::string> vstr = utils::split(quotes_ptr);
	for (std::vector<std::string>::const_iterator it = vstr.begin(); it != vstr.end(); ++ it) {
		const std::string& str = *it;
		int s = str.size();  
		if (s <= 3) {
			continue;
		}
		// ':studio'
		const char* c_str = str.c_str();
		if (c_str[0] == '\'' && c_str[1] == ':' && c_str[s - 1] == '\'') {
			ret.insert(std::string(c_str + 2, s - 3));
		}
	}
	return ret;
}

void write_apps_2_settings_gradle(const std::string& filename, const std::set<std::string>& apps)
{
	VALIDATE(!apps.empty(), null_str);

	// include ':sleep', ':sesame', ':studio', ':aismart', ':iaccess', ':launcher', ':kdesktop'
	std::stringstream ss_file;
	ss_file << "include ";
	for (std::set<std::string>::const_iterator it = apps.begin(); it != apps.end(); ++ it) {
		const std::string& app = *it;
		VALIDATE(!app.empty(), null_str);
		if (it != apps.begin()) {
			ss_file << ", ";
		}
		ss_file << "':" << app << '\'';
	}

	tfile file(filename, GENERIC_WRITE, CREATE_ALWAYS);
	VALIDATE(file.valid(), null_str);
	posix_fwrite(file.fp, ss_file.str().c_str(), ss_file.str().size());
}

static void edit_app_java(const tdomain& default_bundle_id, const tapp_capabilities& capab, const std::string& app_android_prj_app_path)
{
	std::vector<std::pair<std::string, std::string> > replaces;
	replaces.push_back(std::make_pair(default_bundle_id.id(), capab.bundle_id.id()));
	if (capab.ble) {
		replaces.push_back(std::make_pair("mUseBle = false;", "mUseBle = true;"));
	}
	if (capab.wifi) {
		replaces.push_back(std::make_pair("mUseWifi = false;", "mUseWifi = true;"));
	}

	std::stringstream ss;
	ss << app_android_prj_app_path + "/src/main/java/";
	ss << capab.bundle_id.node(0) << "/" << capab.bundle_id.node(1) << "/" << capab.bundle_id.node(2) << "/app.java";
	const std::string file = ss.str();

	file_replace_string(file, replaces);
}

bool texporter::export_android_prj() const
{
	std::stringstream ss;
	const std::string app_in_prj = "studio";
	const tdomain default_bundle_id("com.leagor.studio");

	// example: copier_.app is "kdesktop"

	const std::string& app_android_prj_path = alias_2_path(tapp_copier::app_android_prj_alias);
/*
	// rename <app_android_prj>/studio to <app_android_prj>/kdesktop
	if (!is_studio_app(copier_.app)) {
		SDL_RenameFile((app_android_prj_path + "/studio").c_str(), copier_.app.c_str());
	}
*/
	// app_android_prj_app_path: rename <app_android_prj>/kdesktop
	const std::string app_android_prj_app_path = app_android_prj_path + "/" + copier_.app;

	// <app_android_prj>/kdesktop/src/main/AndroidManifest.xml
	const std::string androidmanifest_xml_tmp = "AndroidManifest.xml.tmp";
	std::string src = app_android_prj_app_path + "/src/main/" + androidmanifest_xml_tmp;
	std::string dst = app_android_prj_app_path + "/src/main/AndroidManifest.xml";
	SDL_RenameFile(dst.c_str(), androidmanifest_xml_tmp.c_str());
	{
		tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file.read_2_data();
		if (!fsize) {
			return false;
		}
		// i think length of appended data isn't more than 512 bytes.
		file.resize_data(fsize + 512, fsize);
		file.data[fsize] = '\0';
		// replace with app's bundle id.
		const char* prefix = "\"http://schemas.android.com/apk/res/android\"";
		const char* ptr = strstr(file.data, prefix);
		if (!ptr) {
			return false;
		}
		ptr = utils::skip_blank_characters(ptr + strlen(prefix) + 1);
		if (memcmp(ptr, "package=\"", 9)) {
			return false;
		}
		ptr += 9;
		if (memcmp(ptr, default_bundle_id.id().c_str(), default_bundle_id.size())) {
			return false;
		}
		if (app_in_prj != copier_.app) {
			fsize = file.replace_span(ptr - file.data, default_bundle_id.size(), copier_.bundle_id.id().c_str(), copier_.bundle_id.size(), fsize);
		}
		file.data[fsize] = '\0';

		if (copier_.ble || copier_.wifi || copier_.bootup) {
			// insert ble permission.
			const char* prefix2 = "<!--app extra uses-permission will insert after it!-->";
			ptr = strstr(ptr, prefix2);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_lines(ptr + strlen(prefix2), 1);
			std::stringstream permission;
			if (copier_.ble) {
				permission << "    <!--uses-permission for ble-->\r\n";
				permission << "    <uses-permission android:name=\"android.permission.BLUETOOTH\" />\r\n";
				permission << "    <uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" />\r\n";
				permission << "    <uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" />\r\n";
				permission << "    <uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" />\r\n";
				permission << "    <uses-feature android:name=\"android.hardware.bluetooth_le\" android:required=\"true\" />\r\n";
				permission << "\r\n";
			}
			if (copier_.wifi) {
				permission << "    <!--uses-permission for wifi-->\r\n";
				permission << "    <uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" />\r\n";
				permission << "    <uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\r\n";
				permission << "\r\n";
			}
			if (copier_.bootup) {
				permission << "    <!--uses-permission for bootup-->\r\n";
				permission << "    <uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\r\n";
				permission << "\r\n";
			}
			
			fsize = file.replace_span(ptr - file.data, 0, permission.str().c_str(), permission.str().size(), fsize);
		}

		if (copier_.bootup) {
			// insert misc receiver.
			const char* prefix2 = "<!--app extra receiver will insert after it!-->";
			ptr = strstr(ptr, prefix2);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_lines(ptr + strlen(prefix2), 1);
			std::stringstream extra_ss;
			extra_ss << "        " << "<receiver android:name=\".BootCompletedReceiver\">\r\n";
            extra_ss << "            " << "<intent-filter>\r\n";
            extra_ss << "                " << "<action android:name=\"android.intent.action.BOOT_COMPLETED\" />\r\n";
            extra_ss << "            " << "</intent-filter>\r\n";
			extra_ss << "        " << "</receiver>\r\n";
			fsize = file.replace_span(ptr - file.data, 0, extra_ss.str().c_str(), extra_ss.str().size(), fsize);
		}

		// write data to new file
		tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
		if (file2.valid()) {
			posix_fseek(file2.fp, 0);
			posix_fwrite(file2.fp, file.data, fsize);
		}
	}
	SDL_DeleteFiles(src.c_str());

	// <app_android_prj>/kdesktop/src/main/java/com/leagor/kdesktop/app.java
	edit_app_java(default_bundle_id, copier_, app_android_prj_app_path);

/*
	// <app_android_prj>/kdesktop/build.gradle
	if (app_in_prj != copier_.app) {
		const std::string build_gradle_tmp = "build.gradle.tmp";
		src = app_android_prj_app_path + "/" + build_gradle_tmp;
		dst = app_android_prj_app_path + "/build.gradle";
		SDL_RenameFile(dst.c_str(), build_gradle_tmp.c_str());
		{
			tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 512 bytes.
			file.resize_data(fsize + 512, fsize);
			file.data[fsize] = '\0';
			// replace with app's bundle id.
			const char* prefix = "defaultConfig {";
			const char* ptr = strstr(file.data, prefix);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_characters(ptr + strlen(prefix) + 1);
			if (memcmp(ptr, "applicationId", 13)) {
				return false;
			}
			ptr += 13;
			ptr = utils::skip_blank_characters(ptr);
			if (ptr[0] != '\"') {
				return false;
			}
			ptr ++;
			if (memcmp(ptr, default_bundle_id.id().c_str(), default_bundle_id.size())) {
				return false;
			}
			fsize = file.replace_span(ptr - file.data, default_bundle_id.size(), copier_.bundle_id.id().c_str(), copier_.bundle_id.size(), fsize);
			file.data[fsize] = '\0';

			// write data to new file
			tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
			if (file2.valid()) {
				posix_fseek(file2.fp, 0);
				posix_fwrite(file2.fp, file.data, fsize);
			}
		}
		SDL_DeleteFiles(src.c_str());
	}

	// <android-prj>/kdesktop/src/main/res/values/strings.xml
	// msgstr of <app> maybe defferent from msgid.
	{
		const std::string strings_xml_tmp = "strings.xml.tmp";
		src = app_android_prj_app_path + "/src/main/res/values/" + strings_xml_tmp;
		dst = app_android_prj_app_path + "/src/main/res/values/strings.xml";
		SDL_RenameFile(dst.c_str(), strings_xml_tmp.c_str());
		{
			tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 512 bytes.
			file.resize_data(fsize + 512, fsize);
			file.data[fsize] = '\0';
			// replace with app's bundle id.
			const char* prefix = "<string name=\"app_name\">";
			const char* ptr = strstr(file.data, prefix);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_characters(ptr + strlen(prefix));

			const std::string app_msgstr = game_config::get_app_msgstr(copier_.app);
			fsize = file.replace_span(ptr - file.data, app_in_prj.size(), app_msgstr.c_str(), app_msgstr.size(), fsize);

			// write data to new file
			tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
			if (file2.valid()) {
				posix_fseek(file2.fp, 0);
				posix_fwrite(file2.fp, file.data, fsize);
			}
		}
		SDL_DeleteFiles(src.c_str());
	}
*/

	// <android_prj>/kdesktop/jni/Android.mk
	if (app_in_prj != copier_.app) {
		const std::string android_mk_tmp = "Android.mk.tmp";
		src = app_android_prj_app_path + "/jni/" + android_mk_tmp;
		dst = app_android_prj_app_path + "/jni/Android.mk";
		SDL_RenameFile(dst.c_str(), android_mk_tmp.c_str());
		{
			std::vector<std::string> vstr;
			tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 1024 bytes.
			file.resize_data(fsize + 1024, fsize);
			file.data[fsize] = '\0';

			std::string prefix;
			const char* ptr = NULL;

			if (app_in_prj != copier_.app) {
				// studio
				prefix = app_in_prj;
				ptr = strstr(file.data, prefix.c_str());
				while (ptr) {
					fsize = file.replace_span(ptr - file.data, prefix.size(), copier_.app.c_str(), copier_.app.size(), fsize);
					// replace next
					ptr = strstr(ptr, prefix.c_str());
				}
			}

			std::stringstream ss;
			//
			// insert extra include directories
			//
			prefix = "$(LOCAL_PATH)/" + copier_.app;
			ptr = strstr(file.data, prefix.c_str());
			VALIDATE(ptr, null_str);
			ptr += prefix.size();
			std::set<std::string> extra_directories = app_include_directories(copier_.app);
			ss.str("");
			const std::string app_include_dir = "../../" + copier_.app;
			const std::string app_include_dir_prefix = "../../";
			const std::string fake_prefix = "/a/b/c/";
			for (std::set<std::string>::const_iterator it = extra_directories.begin(); it != extra_directories.end(); ++ it) {
				const std::string& include = *it;
				if (include == app_include_dir) {
					continue;
				}
				// app's include directory maybe not in ../../launcher
				// for example, ../../launcher/../external/freerdp/include ==> $(LOCAL_PATH)/external/freerdp/include
				const std::string include2 = utils::normalize_path(fake_prefix + include.substr(app_include_dir_prefix.size()));
				if (include2.find(fake_prefix) == 0) {
					ss << " \\\n\t$(LOCAL_PATH)/" << include2.substr(fake_prefix.size());
				} else {
					// cannot normalize it.
					ss << " \\\n\t$(LOCAL_PATH)/" << copier_.app << include.substr(app_include_dir.size());
				}
			}
			if (!ss.str().empty()) {
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			}

			//
			// insert extra c/cc/cpp files
			//
			prefix = "$(subst $(LOCAL_PATH)/,, \\";
			ptr = strstr(file.data, prefix.c_str());
			VALIDATE(ptr, null_str);
			ptr += prefix.size();
			std::map<std::string, uint32_t> cpp_files;
			const std::string app_dir = game_config::apps_src_path + "/apps/";
			walk_dir(app_dir + copier_.app, true, std::bind(
					&texporter::collect_cpp_files
					, this
					, _1, _2, std::ref(cpp_files)));
			ss.str("");
			const std::string gui_dialogs = copier_.app + "/gui/dialogs";
			for (std::map<std::string, uint32_t>::const_iterator it = cpp_files.begin(); it != cpp_files.end(); ++ it) {
				const std::string short_dir = it->first.substr(app_dir.size());
				if (short_dir == gui_dialogs) {
					continue;
				}
				if (it->second & C_FLAG) {
					ss << "\n\t$(wildcard $(LOCAL_PATH)/" << short_dir << "/*.c) \\";
				} else if (it->second & CC_FLAG) {
					ss << "\n\t$(wildcard $(LOCAL_PATH)/" << short_dir << "/*.cc) \\";
				} else if (it->second & CPP_FLAG) {
					ss << "\n\t$(wildcard $(LOCAL_PATH)/" << short_dir << "/*.cpp) \\";
				}
			}
			if (!ss.str().empty()) {
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			}

			const tapp_capabilities::tos& os_special = copier_.os_special.find(os_android)->second;
			if (!os_special.extra_libs.empty()) {
				//
				// insert extra libs
				//
				prefix = "LOCAL_LDLIBS :=";
				ptr = strstr(file.data, prefix.c_str());
				VALIDATE(ptr, null_str);
				ptr += prefix.size();

				ss.str("");
				for (std::vector<std::string>::const_iterator it = os_special.extra_libs.begin(); it != os_special.extra_libs.end(); ++ it) {
					ss << " -l" << extract_android_lib_stem(*it);
				}
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			}

			if (!os_special.extra_LOCAL_CFLAGS.empty()) {
				//
				// insert extra LOCAL_CFLAGS
				//
				prefix = "# app extra LOCAL_CFLAGS will insert after it";
				ptr = strstr(file.data, prefix.c_str());
				VALIDATE(ptr, "cannot find " + prefix + " in <android-prj>/Android.mk");
				ptr += prefix.size();
				ptr = utils::skip_blank_lines(ptr, 1);

				ss.str("");
				ss << "LOCAL_CFLAGS += " << utils::join(os_special.extra_LOCAL_CFLAGS, " ") << "\n";
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			}

			if (!os_special.extra_external_mks.empty()) {
				//
				// insert extra external mk
				//
				prefix = "# app extra external mk will insert after it";
				ptr = strstr(file.data, prefix.c_str());
				VALIDATE(ptr, "cannot find " + prefix + " in <android-prj>/Android.mk");
				ptr += prefix.size();
				ptr = utils::skip_blank_lines(ptr, 1);

				ss.str("");
				for (std::vector<std::string>::const_iterator it = os_special.extra_external_mks.begin(); it != os_special.extra_external_mks.end(); ++ it) {
					ss << "include $(LOCAL_PATH)/external/" << *it << "\n";
				}
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			}
			
			// write data to new file
			tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
			if (file2.valid()) {
				posix_fseek(file2.fp, 0);
				posix_fwrite(file2.fp, file.data, fsize);
			}
		}
		SDL_DeleteFiles(src.c_str());
	}

	// if (app_in_prj != copier_.app) {
	{
		// form ic_launcher-192.png to misc ic_launcher.png
		std::stringstream file_ss;
		const std::string full_file = game_config::path + "/" + game_config::generate_app_dir(copier_.app) + "/images/assets/ic_launcher-";
		file_ss << full_file << "192.png";
		surface surf = image::get_image(file_ss.str());
		std::map<int, std::string> dpis;
		dpis.insert(std::make_pair(48, "mipmap-mdpi"));
		dpis.insert(std::make_pair(72, "mipmap-hdpi"));
		dpis.insert(std::make_pair(96, "mipmap-xhdpi"));
		dpis.insert(std::make_pair(144, "mipmap-xxhdpi"));
		dpis.insert(std::make_pair(192, "mipmap-xxxhdpi"));
		for (std::map<int, std::string>::const_iterator it = dpis.begin(); it != dpis.end(); ++ it) {
			const std::string dst = app_android_prj_app_path + "/src/main/res/" + it->second + "/ic_launcher.png";
			VALIDATE(SDL_IsFile(dst.c_str()), null_str);
			file_ss.str("");
			file_ss << full_file << it->first << ".png";
			surface target_surf = image::get_image(file_ss.str());
			if (target_surf.get() && target_surf->w == it->first && target_surf->h == it->first) {
				SDL_CopyFiles(file_ss.str().c_str(), dst.c_str());
			} else {
				surface scaled = scale_surface(surf, it->first, it->first);
				const std::string dst = app_android_prj_app_path + "/src/main/res/" + it->second + "/ic_launcher.png";
				IMG_SavePNG(scaled, dst.c_str());
			}
		}
	}

/*
	// <android_prj>/settings.gradle
	if (!is_studio_app(copier_.app)) {
		src = app_android_prj_path + "/settings.gradle";
		std::set<std::string> apps = read_apps_from_settings_gradle(src);
		VALIDATE(apps.size() == 1 && apps.count(copier_.app) == 0, null_str);
		apps.clear();
		apps.insert(copier_.app);
		write_apps_2_settings_gradle(src, apps);
	}

	std::string app_src_path = alias_2_path(app_src_alias);
	std::string app_src2_path = alias_2_path(app_src2_alias);
	std::replace(app_src_path.begin(), app_src_path.end(), path_sep(false), path_sep(true));
	// <app_src>/scripts/android_set_variable.tpl
	src = app_src_path + "/scripts/android_set_variable.tpl";
	if (SDL_IsFile(src.c_str())) {
		std::vector<std::pair<std::string, std::string> > replaces;
		replaces.push_back(std::make_pair("%_APP_SRC%", app_src_path));
		file_replace_string(app_src_path + "/scripts/android_set_variable.tpl", app_src_path + "/scripts/android_set_variable.bat", replaces);

		tfile file2(app_src_path + "/scripts/android_set_variable.bat", GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file2.read_2_data();
		// i think length of appended data isn't more than 512 bytes.
		file2.resize_data(fsize + 512, fsize);
		file2.data[fsize] = '\0';

		// app directory
		std::stringstream app_dir;
		app_dir << "\n\nset " << copier_.app << "=" << app_src2_path << "/projectfiles/android/" << copier_.app;
		
		std::string app_dir_str = app_dir.str();
		std::replace(app_dir_str.begin(), app_dir_str.end(), path_sep(false), path_sep(true));
		fsize = file2.replace_span(fsize, 0, app_dir_str.c_str(), app_dir_str.size(), fsize);

		posix_fseek(file2.fp, 0);
		posix_fwrite(file2.fp, file2.data, fsize);
	}
	if (!is_studio_app(copier_.app)) {
		SDL_DeleteFiles((app_src_path + "/scripts/android_set_variable.tpl").c_str());
	}
*/
	return true;
}

bool texporter::generate_kos_prj() const
{
	// fixed in future
	return true;

	const std::string app_in_prj = "studio";
	const tdomain default_bundle_id("com.leagor.studio");

	const std::string& app_kos_prj_path = alias_2_path(tapp_copier::app_kos_prj_alias);
	// rename <app_android_prj>/studio to <app_android_prj>/kdesktop
	if (!is_studio_app(copier_.app)) {
		SDL_RenameFile((app_kos_prj_path + "/studio").c_str(), copier_.app.c_str());
	}
	const std::string app_kos_prj_app_path = app_kos_prj_path + "/" + copier_.app;
	std::string src;
	std::string dst;

	// <kos_prj>/studio/jni/Android.mk
	if (app_in_prj != copier_.app) {
		const std::string android_mk_tmp = "Android.mk.tmp";
		src = app_kos_prj_app_path + "/jni/" + android_mk_tmp;
		dst = app_kos_prj_app_path + "/jni/Android.mk";
		SDL_RenameFile(dst.c_str(), android_mk_tmp.c_str());
		{
			std::vector<std::string> vstr;
			tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 1024 bytes.
			file.resize_data(fsize + 1024, fsize);
			file.data[fsize] = '\0';

			std::string prefix;
			const char* ptr = NULL;

			{
				// replace 'studio' with copier_.app
				prefix = app_in_prj;
				ptr = strstr(file.data, prefix.c_str());
				while (ptr) {
					fsize = file.replace_span(ptr - file.data, prefix.size(), copier_.app.c_str(), copier_.app.size(), fsize);
					// replace next
					ptr = strstr(ptr, prefix.c_str());
				}
			}

			std::stringstream ss;
			//
			// insert extra include directories
			//
			prefix = "$(LOCAL_PATH)/" + copier_.app;
			ptr = strstr(file.data, prefix.c_str());
			VALIDATE(ptr, null_str);
			ptr += prefix.size();
			std::set<std::string> extra_directories = app_include_directories(copier_.app);
			ss.str("");
			const std::string app_include_dir = "../../" + copier_.app;
			for (std::set<std::string>::const_iterator it = extra_directories.begin(); it != extra_directories.end(); ++ it) {
				const std::string& include = *it;
				if (include == app_include_dir) {
					continue;
				}
				ss << " \\\n\t$(LOCAL_PATH)/" << copier_.app << include.substr(app_include_dir.size()); 
			}
			if (!ss.str().empty()) {
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			}

			//
			// insert extra c/cc/cpp files
			//
			prefix = "$(subst $(LOCAL_PATH)/,, \\";
			ptr = strstr(file.data, prefix.c_str());
			VALIDATE(ptr, null_str);
			ptr += prefix.size();
			std::map<std::string, uint32_t> cpp_files;
			const std::string app_dir = game_config::apps_src_path + "/apps/";
			walk_dir(app_dir + copier_.app, true, std::bind(
					&texporter::collect_cpp_files
					, this
					, _1, _2, std::ref(cpp_files)));
			ss.str("");
			const std::string gui_dialogs = copier_.app + "/gui/dialogs";
			for (std::map<std::string, uint32_t>::const_iterator it = cpp_files.begin(); it != cpp_files.end(); ++ it) {
				const std::string short_dir = it->first.substr(app_dir.size());
				if (short_dir == gui_dialogs) {
					continue;
				}
				if (it->second & C_FLAG) {
					ss << "\n\t$(wildcard $(LOCAL_PATH)/" << short_dir << "/*.c) \\";
				} else if (it->second & CC_FLAG) {
					ss << "\n\t$(wildcard $(LOCAL_PATH)/" << short_dir << "/*.cc) \\";
				} else if (it->second & CPP_FLAG) {
					ss << "\n\t$(wildcard $(LOCAL_PATH)/" << short_dir << "/*.cpp) \\";
				}
			}
			if (!ss.str().empty()) {
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			}

			const tapp_capabilities::tos& os_special = copier_.os_special.find(os_android)->second;
			if (!os_special.extra_libs.empty()) {
				//
				// insert extra libs
				//
				prefix = "LOCAL_LDLIBS :=";
				ptr = strstr(file.data, prefix.c_str());
				VALIDATE(ptr, null_str);
				ptr += prefix.size();

				ss.str("");
				for (std::vector<std::string>::const_iterator it = os_special.extra_libs.begin(); it != os_special.extra_libs.end(); ++ it) {
					ss << " -l" << extract_android_lib_stem(*it);
				}
				fsize = file.replace_span(ptr - file.data, 0, ss.str().c_str(), ss.str().size(), fsize);
			}
			
			// write data to new file
			tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
			if (file2.valid()) {
				posix_fseek(file2.fp, 0);
				posix_fwrite(file2.fp, file.data, fsize);
			}
		}
		SDL_DeleteFiles(src.c_str());
	}

	std::string app_src_path = alias_2_path(app_src_alias);
	std::string app_src2_path = alias_2_path(app_src2_alias);
	std::replace(app_src_path.begin(), app_src_path.end(), path_sep(false), path_sep(true));
	// <app_src>/scripts/kos_set_variable.tpl
	{
		std::vector<std::pair<std::string, std::string> > replaces;
		replaces.push_back(std::make_pair("%_APP_SRC%", app_src_path));
		file_replace_string(app_src_path + "/scripts/kos_set_variable.tpl", app_src_path + "/scripts/kos_set_variable.bat", replaces);

		tfile file2(app_src_path + "/scripts/kos_set_variable.bat", GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file2.read_2_data();
		// i think length of appended data isn't more than 512 bytes.
		file2.resize_data(fsize + 512, fsize);
		file2.data[fsize] = '\0';

		// app directory
		std::stringstream app_dir;
		app_dir << "\n\nset " << copier_.app << "=" << app_src2_path << "/projectfiles/kos/" + copier_.app;
		
		std::string app_dir_str = app_dir.str();
		std::replace(app_dir_str.begin(), app_dir_str.end(), path_sep(false), path_sep(true));
		fsize = file2.replace_span(fsize, 0, app_dir_str.c_str(), app_dir_str.size(), fsize);

		posix_fseek(file2.fp, 0);
		posix_fwrite(file2.fp, file2.data, fsize);
	}
	if (!is_studio_app(copier_.app)) {
		SDL_DeleteFiles((app_src_path + "/scripts/kos_set_variable.tpl").c_str());
	}

	return true;
}


void tstudio_extra_exporter::app_complete_paths()
{
	copier_.app_complete_paths(paths_);
}

bool tstudio_extra_exporter::studio_export_android_prj() const
{
	const std::string app_in_prj = "studio";
	const tdomain default_bundle_id("com.leagor.studio");

	VALIDATE(is_studio_app(copier_.app), null_str);

	const std::string& app_android_prj_path = alias_2_path(tapp_copier::app_android_prj_alias);
	// app_android_prj_app_path: rename <app_android_prj>/kdesktop
	// const std::string app_android_prj_app_path = app_android_prj_path + "/" + copier_.app;

	std::string app_src_path = alias_2_path(app_src_alias);
	std::string app_src2_path = alias_2_path(app_src2_alias);
	std::replace(app_src_path.begin(), app_src_path.end(), path_sep(false), path_sep(true));

	// <app_src>/scripts/android_set_variable.tpl
	std::string src = app_src_path + "/scripts/android_set_variable.tpl";
	VALIDATE(SDL_IsFile(src.c_str()), "cannot find <scripts>/android_set_variable.tpl");
	{
		std::vector<std::pair<std::string, std::string> > replaces;
		replaces.push_back(std::make_pair("%_APP_SRC%", app_src_path));
		file_replace_string(app_src_path + "/scripts/android_set_variable.tpl", app_src_path + "/scripts/android_set_variable.bat", replaces);

		tfile file2(app_src_path + "/scripts/android_set_variable.bat", GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file2.read_2_data();
		// i think length of appended data isn't more than 512 bytes.
		file2.resize_data(fsize + 512, fsize);
		file2.data[fsize] = '\0';

		// app directory
		std::stringstream app_dir;
		app_dir << "\n\nset " << copier_.app << "=" << app_src2_path << "/projectfiles/android/" << copier_.app;
		
		std::string app_dir_str = app_dir.str();
		std::replace(app_dir_str.begin(), app_dir_str.end(), path_sep(false), path_sep(true));
		fsize = file2.replace_span(fsize, 0, app_dir_str.c_str(), app_dir_str.size(), fsize);

		posix_fseek(file2.fp, 0);
		posix_fwrite(file2.fp, file2.data, fsize);
	}

	return true;
}

bool tstudio_extra_exporter::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}
/*
	if (!generate_window_prj()) {
		return false;
	}
*/
	if (!studio_export_android_prj()) {
		return false;
	}

	return true;
}


void tother_extra_exporter::app_complete_paths()
{
	copier_.app_complete_paths(paths_);
}

std::vector<std::pair<std::string, std::string> > tother_extra_exporter::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!copier_.app.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", copier_.app));

	std::stringstream slash_bundle_ss;
	slash_bundle_ss << copier_.bundle_id.node(0) << "/" << copier_.bundle_id.node(1) << "/" << copier_.bundle_id.node(2);
	ret.push_back(std::make_pair("<__slash_bundle__>", slash_bundle_ss.str()));
	return ret;
}

void tandroid_res::app_complete_paths()
{
	copier_.app_complete_paths(paths_);
}

bool tandroid_res::app_can_execute(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}
	return is_directory(get_android_res_path());
}

bool tandroid_res::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}
/*
	{
		// generate __cookie.cki on every directory.
		// <aismart-src>/projectfiles/android/<__app__>/src/main/assets/res
		tcopy_cookie ccp(alias_2_path(app_src2_alias) + "/projectfiles/android/" + copier_.app + "/src/main/assets/res");
		walk_dir(ccp.current_path, false, std::bind(&tcopy_cookie::cb_copy_cookie, &ccp, _1, _2));
	}
*/

	std::stringstream ss;
	{
		// generate __cookie.cki on every directory.
		// <apps-src>/apps/projectfiles/android/studio/src/main/assets/res
		tcopy_cookie ccp(get_android_res_path());
		walk_dir(ccp.current_path, false, std::bind(&tcopy_cookie::cb_copy_cookie, &ccp, _1, _2));
	}

	return true;
}

std::vector<std::pair<std::string, std::string> > tandroid_res::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!copier_.app.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", copier_.app));

	std::stringstream slash_bundle_ss;
	slash_bundle_ss << copier_.bundle_id.node(0) << "/" << copier_.bundle_id.node(1) << "/" << copier_.bundle_id.node(2);
	ret.push_back(std::make_pair("<__slash_bundle__>", slash_bundle_ss.str()));
	return ret;
}

std::string tandroid_res::get_android_res_path()
{
	std::stringstream ss;

	ss << alias_2_path(ttask::src2_alias);
	ss << "/projectfiles/android/";
	ss << copier_.app;
	ss << "/src/main/assets/res";

	return ss.str();
}


const std::string tios_kit::kit_alias = "kit";
const std::string tios_kit::studio_alias = "studio";

bool tios_kit::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	// const std::string& app_res_path = alias_2_path(app_res_alias)
	// const std::string& app_ios_prj_path = alias_2_path(tapp_copier::app_ios_prj_alias)
	const std::string& studio_path = alias_2_path(studio_alias);
	if (!generate_ios_prj(copier_, studio_path, studio_path + "/projectfiles/Xcode-iOS")) {
		return false;
	}

	return true;
}

std::vector<std::pair<std::string, std::string> > tios_kit::app_get_replace(const tsubtask& subtask)
{
	const std::string replacee = "<__app__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, "studio"));
}


const std::string tnewer::windows_prj_alias = "windows_prj";

void tnewer::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > tnewer::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!capab_.app.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", capab_.app));
	ret.push_back(std::make_pair("<__bundle__>", capab_.bundle_id.id()));
	std::stringstream slash_bundle_ss;
	slash_bundle_ss << capab_.bundle_id.node(0) << "/" << capab_.bundle_id.node(1) << "/" << capab_.bundle_id.node(2);
	ret.push_back(std::make_pair("<__slash_bundle__>", slash_bundle_ss.str()));
	return ret;
}

void insert_app_to_android_prj(const std::string& app, const std::string& src_path, const std::string& src2_path)
{
	VALIDATE(!is_studio_app(app), null_str);
	std::string src;

	const std::string android_path = src2_path + "/projectfiles/android";

	// <android>/settings.gradle
	{
		src = android_path + "/settings.gradle";
		std::set<std::string> apps = read_apps_from_settings_gradle(src);
		VALIDATE(apps.count(app) == 0, null_str);
		apps.insert(app);
		write_apps_2_settings_gradle(src, apps);
	}

	// std::string adjucted_src_path = src_path;
	// std::replace(adjucted_src_path.begin(), adjucted_src_path.end(), path_sep(false), path_sep(true));
	// <app_src>/scripts/android_set_variable.bat
	{
		std::vector<std::pair<std::string, std::string> > replaces;

		tfile file2(src_path + "/scripts/android_set_variable.bat", GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file2.read_2_data();
		// i think length of appended data isn't more than 512 bytes.
		file2.resize_data(fsize + 512, fsize);
		file2.data[fsize] = '\0';

		// app directory
		std::stringstream app_dir;
		app_dir << "\nset " << app << "=" << src2_path << "/projectfiles/android/" << app;
		
		std::string app_dir_str = app_dir.str();
		std::replace(app_dir_str.begin(), app_dir_str.end(), path_sep(false), path_sep(true));
		fsize = file2.replace_span(fsize, 0, app_dir_str.c_str(), app_dir_str.size(), fsize);

		posix_fseek(file2.fp, 0);
		posix_fwrite(file2.fp, file2.data, fsize);
	}
}

bool tnewer::new_android_prj() const
{
	std::stringstream ss;
	const std::string app_in_prj = "studio";
	const tdomain default_bundle_id("com.leagor.studio");

	VALIDATE(!is_studio_app(capab_.app), null_str);

	// example: app_ is "kdesktop"

	const std::string app_android_prj_path = alias_2_path(src2_alias) + "/projectfiles/android";
	// app_android_prj_app_path: rename <app_android_prj>/kdesktop
	const std::string app_android_prj_app_path = app_android_prj_path + "/" + capab_.app;

	std::string src;
	std::string dst;

	// <app_android_prj>/kdesktop/src/main/java/com/leagor/kdesktop/app.java
	edit_app_java(default_bundle_id, capab_, app_android_prj_app_path);

	// <android-prj>/kdesktop/src/main/res/values/strings.xml
	// msgstr of <app> maybe defferent from msgid.
	{
		const std::string strings_xml_tmp = "strings.xml.tmp";
		src = app_android_prj_app_path + "/src/main/res/values/" + strings_xml_tmp;
		dst = app_android_prj_app_path + "/src/main/res/values/strings.xml";
		SDL_RenameFile(dst.c_str(), strings_xml_tmp.c_str());
		{
			tfile file(src, GENERIC_WRITE, OPEN_EXISTING);
			int fsize = file.read_2_data();
			if (!fsize) {
				return false;
			}
			// i think length of appended data isn't more than 512 bytes.
			file.resize_data(fsize + 512, fsize);
			file.data[fsize] = '\0';
			// replace with app's bundle id.
			const char* prefix = "<string name=\"app_name\">";
			const char* ptr = strstr(file.data, prefix);
			if (!ptr) {
				return false;
			}
			ptr = utils::skip_blank_characters(ptr + strlen(prefix));

			const std::string app_msgstr = game_config::get_app_msgstr(capab_.app);
			fsize = file.replace_span(ptr - file.data, app_in_prj.size(), app_msgstr.c_str(), app_msgstr.size(), fsize);

			// write data to new file
			tfile file2(dst, GENERIC_WRITE, CREATE_ALWAYS);
			if (file2.valid()) {
				posix_fseek(file2.fp, 0);
				posix_fwrite(file2.fp, file.data, fsize);
			}
		}
		SDL_DeleteFiles(src.c_str());
	}

	insert_app_to_android_prj(capab_.app, alias_2_path(src_alias), alias_2_path(src2_alias));
	return true;
}

bool tnewer::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	if (!new_android_prj()) {
		return false;
	}
	return true;
}


//
// applet newer
//
const std::string taplt_newer::windows_prj_alias = "windows_prj";

void taplt_newer::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > taplt_newer::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(bundleid_.valid(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__bundle__>", bundleid_.id()));
	ret.push_back(std::make_pair("<__lua_bundle__>", utils::replace_all(bundleid_.id(), ".", "_")));
	std::stringstream slash_bundle_ss;
	slash_bundle_ss << bundleid_.node(0) << "/" << bundleid_.node(1) << "/" << bundleid_.node(2);
	ret.push_back(std::make_pair("<__slash_bundle__>", slash_bundle_ss.str()));
	return ret;
}

std::vector<std::string> taplt_newer::sln_files() const
{
	VALIDATE(bundleid_.valid(), null_str);
	const std::string lua_bundleid = bundleid_2_lua_bundleid(bundleid_.id());

	std::vector<std::string> ret;
	ret.push_back(lua_bundleid + "/lua/home.lua");
	ret.push_back(lua_bundleid + "/lua/main.lua");
	ret.push_back(lua_bundleid + "/settings.cfg");

	return ret;
}

//
// app importer
//
void timporter::set_app(const std::string& app, const std::string& res_path, const std::string& src2_path)
{
	app_ = app;

	set_alias(app_res_alias, res_path);
	set_alias(app_src2_alias, src2_path);
}

std::vector<std::pair<std::string, std::string> > timporter::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", app_));
	return ret;
}

bool timporter::import_android_prj() const
{
	VALIDATE(!is_studio_app(app_), null_str);

	std::string src;

	const std::string android_path = alias_2_path(src2_alias) + "/projectfiles/android";

	// <android>/settings.gradle
	{
		src = android_path + "/settings.gradle";
		std::set<std::string> apps = read_apps_from_settings_gradle(src);
		VALIDATE(apps.count(app_) == 0, null_str);
		apps.insert(app_);
		write_apps_2_settings_gradle(src, apps);
	}

	std::string src_path = alias_2_path(src_alias);
	std::string src2_path = alias_2_path(src2_alias);
	std::replace(src_path.begin(), src_path.end(), path_sep(false), path_sep(true));
	// <app_src>/scripts/android_set_variable.bat
	{
		std::vector<std::pair<std::string, std::string> > replaces;

		tfile file2(src_path + "/scripts/android_set_variable.bat", GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file2.read_2_data();
		// i think length of appended data isn't more than 512 bytes.
		file2.resize_data(fsize + 512, fsize);
		file2.data[fsize] = '\0';

		// app directory
		std::stringstream app_dir;
		app_dir << "\nset " << app_ << "=" << src2_path << "/projectfiles/android/" << app_;
		
		std::string app_dir_str = app_dir.str();
		std::replace(app_dir_str.begin(), app_dir_str.end(), path_sep(false), path_sep(true));
		fsize = file2.replace_span(fsize, 0, app_dir_str.c_str(), app_dir_str.size(), fsize);

		posix_fseek(file2.fp, 0);
		posix_fwrite(file2.fp, file2.data, fsize);
	}

	return true;
}

bool timporter::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}
/*
	if (!import_window_prj()) {
		return false;
	}
*/
	if (!import_android_prj()) {
		return false;
	}
/*
	if (!import_kos_prj()) {
		return false;
	}

	if (!importe_ios_prj(copier_, alias_2_path(app_res_alias), alias_2_path(tapp_copier::app_ios_prj_alias))) {
		return false;
	}
*/
	{
		// generate __cookie.cki on every directory.
		// "<apps-src/apps>/projectfiles/android/studio/src/main/assets/res"
		tcopy_cookie ccp(alias_2_path(src2_alias) + "/projectfiles/android/" + app_ + "/src/main/assets/res");
		walk_dir(ccp.current_path, false, std::bind(&tcopy_cookie::cb_copy_cookie, &ccp, _1, _2));
	}

	return true;
}

//
// app remover
//
std::vector<std::pair<std::string, std::string> > tremover::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty(), null_str);

	const std::string replacee = "<__app__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, app_));
}

bool tremover::remove_android_prj() const
{
	VALIDATE(!is_studio_app(app_), null_str);

	std::string src;

	const std::string android_path = alias_2_path(src2_alias) + "/projectfiles/android";

	// <android>/settings.gradle
	{
		src = android_path + "/settings.gradle";
		std::set<std::string> apps = read_apps_from_settings_gradle(src);
		std::set<std::string>::iterator find_it = apps.find(app_);
		if (find_it != apps.end()) {
			apps.erase(app_);
			VALIDATE(!apps.empty(), null_str);
			write_apps_2_settings_gradle(src, apps);
		}
	}

	std::string src_path = alias_2_path(src_alias);
	std::replace(src_path.begin(), src_path.end(), path_sep(false), path_sep(true));
	// <app_src>/scripts/android_set_variable.bat
	{
		tfile file(src_path + "/scripts/android_set_variable.bat", GENERIC_WRITE, OPEN_EXISTING);
		int fsize = file.read_2_data();
		VALIDATE(fsize > 0, null_str);

		// remove line: kdesktop=C:\ddksample\studio\apps-src\apps\projectfiles\android\kdesktop
		const std::string prefix = app_ + "=";
		const char* mid = strstr(file.data, prefix.c_str());
		if (mid != nullptr) {
			std::pair<const char*, int> result = this_line_characters(file.data, fsize, mid, prefix.size());
			fsize = file.replace_span(result.first - file.data, result.second, nullptr, 0, fsize);
			int pos = result.first - file.data;
			if (pos != fsize) {
				posix_fseek(file.fp, pos);
				posix_fwrite(file.fp, result.first, fsize - pos);
			}
			file.truncate(fsize);
		}
	}

	return true;
}

bool tremover::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	if (!remove_android_prj()) {
		return false;
	}

	std::vector<std::string> languages;
	walk_dir(game_config::path + "/translations", 0, 
		std::bind(&tremover::did_language, this, _1, _2, std::ref(languages)));

	// remove bonus *.mo
	for (std::set<std::string>::const_iterator it = tdomains_.begin(); it != tdomains_.end(); ++ it) {
		for (std::vector<std::string>::const_iterator it2 = languages.begin(); it2 != languages.end(); ++ it2) {
			const std::string file = game_config::path + "/translations/" + *it2 + "/LC_MESSAGES/" + *it + ".mo";
			SDL_DeleteFiles(file.c_str());
		}
	}

	return true;
}

bool tremover::did_language(const std::string& dir, const SDL_dirent2* dirent, std::vector<std::string>& languages)
{
	bool isdir = SDL_DIRENT_DIR(dirent->mode);
	if (isdir) {
		std::vector<std::string> vstr = utils::split(dirent->name, '_');
		if (vstr.size() == 2) {
			languages.push_back(dirent->name);
		}
	}
	return true;
}

//
// applet remover
//
std::vector<std::pair<std::string, std::string> > taplt_remover::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(is_lua_bundleid(lua_bundleid_), null_str);

	const std::string replacee = "<__LUA_BUNDLE__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, lua_bundleid_));
}

bool taplt_remover::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	return true;
}


//
// new window
//
void tnew_window::set_app(const std::string& app, const std::string& id)
{
	VALIDATE(!app.empty() && !id.empty(), null_str);

	app_ = app;
	id_ = id;
}

std::vector<std::pair<std::string, std::string> > tnew_window::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty() && !id_.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", app_));
	ret.push_back(std::make_pair("<__id__>", id_));
	ret.push_back(std::make_pair("<__ID__>", utils::uppercase(id_)));
	return ret;
}


std::vector<std::string> tnew_dialog::sln_files()
{
	VALIDATE(!app_.empty() && !id_.empty(), null_str);

	std::vector<std::string> ret;
	ret.push_back("gui/dialogs/" + id_ + ".cpp");
	ret.push_back("gui/dialogs/" + id_ + ".hpp");

	return ret;
}

std::vector<std::string> tnew_scene::sln_files()
{
	VALIDATE(!app_.empty() && !id_.empty(), null_str);
	std::vector<std::string> ret;
	ret.push_back(id_ + "_controller.cpp");
	ret.push_back(id_ + "_controller.hpp");
	ret.push_back(id_ + "_display.cpp");
	ret.push_back(id_ + "_display.hpp");
	if (unit_files_) {
		ret.push_back("unit_map.cpp");
		ret.push_back("unit_map.hpp");
		ret.push_back("unit.cpp");
		ret.push_back("unit.hpp");
	}

	ret.push_back("gui/dialogs/" + id_ + "_scene.cpp");
	ret.push_back("gui/dialogs/" + id_ + "_scene.hpp");
	return ret;
}

bool tnew_scene::app_can_execute(const tsubtask& subtask, const bool last)
{
	return unit_files_ || subtask.id().find("unit_files") == std::string::npos;
}

//
// aplt new dialog
// 
void taplt_new_dialog::set_aplt(const std::string& lua_bundleid, const std::string& id)
{
	VALIDATE(is_lua_bundleid(lua_bundleid) && !id.empty(), null_str);

	lua_bundleid_ = lua_bundleid;
	id_ = id;
}

std::vector<std::pair<std::string, std::string> > taplt_new_dialog::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(is_lua_bundleid(lua_bundleid_) && !id_.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__LUA_BUNDLE__>", lua_bundleid_));
	ret.push_back(std::make_pair("<__id__>", id_));
	ret.push_back(std::make_pair("<__ID__>", utils::uppercase(id_)));
	return ret;
}


std::vector<std::string> taplt_new_dialog::sln_files() const
{
	VALIDATE(is_lua_bundleid(lua_bundleid_) && !id_.empty(), null_str);

	std::vector<std::string> ret;
	ret.push_back(lua_bundleid_ + "/lua/" + id_ + ".lua");

	return ret;
}

//
// app validater
//
const std::string tvalidater::windows_prj_alias = "windows_prj";

void tvalidater::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > tvalidater::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!app_.empty(), null_str);

	const std::string replacee = "<__app__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, app_));
}

//
// applet validater
//
const std::string taplt_validater::windows_prj_alias = "windows_prj";

void taplt_validater::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > taplt_validater::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(is_lua_bundleid(lua_bundleid_), null_str);

	const std::string replacee = "<__lua_bundle__>";
	return std::vector<std::pair<std::string, std::string> >(1, std::make_pair(replacee, lua_bundleid_));
}


const std::string tsave_theme::windows_prj_alias = "windows_prj";

void tsave_theme::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > tsave_theme::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!fields_.app.empty(), null_str);
	VALIDATE(!fields_.id.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", fields_.app));
	ret.push_back(std::make_pair("<__theme__>", fields_.id));
	return ret;
}

bool tsave_theme::app_post_handle(const tsubtask& subtask, const bool last)
{
	if (!last) {
		return true;
	}

	config cfg;
	config& theme_cfg = cfg.add_child("theme");
	theme_cfg["app"] = fields_.app;
	theme_cfg["id"] = fields_.id;

	std::string prefix;
	for (int tpl = 0; tpl < theme::color_tpls; tpl ++) {
		prefix.clear();
		if (tpl == theme::inverse_tpl) {
			prefix = "inverse_";
		} else if (tpl == theme::title_tpl) {
			prefix = "title_";
		}

		theme_cfg[prefix + "normal_color"] = encode_color(fields_.text_color_tpls[tpl].normal);
		theme_cfg[prefix + "disable_color"] = encode_color(fields_.text_color_tpls[tpl].disable);
		theme_cfg[prefix + "focus_color"] = encode_color(fields_.text_color_tpls[tpl].focus);
		theme_cfg[prefix + "placeholder_color"] = encode_color(fields_.text_color_tpls[tpl].placeholder);
	}

	// other color
	theme_cfg["item_focus_color"] = encode_color(fields_.item_focus_color);
	theme_cfg["item_highlight_color"] = encode_color(fields_.item_highlight_color);
	theme_cfg["menu_focus_color"] = encode_color(fields_.menu_focus_color);

	std::stringstream ss;
	::write(ss, cfg);

	const std::string path = game_config::path + "/" + game_config::generate_app_dir(fields_.app) + "/theme/" + fields_.id + ".cfg";
	tfile file(path, GENERIC_WRITE, CREATE_ALWAYS);
	VALIDATE(file.valid(), null_str);
	posix_fwrite(file.fp, ss.str().c_str(), ss.str().size());

	return true;
}


const std::string tremove_theme::windows_prj_alias = "windows_prj";

void tremove_theme::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > tremove_theme::app_get_replace(const tsubtask& subtask)
{
	VALIDATE(!fields_.app.empty(), null_str);
	VALIDATE(!fields_.id.empty(), null_str);

	std::vector<std::pair<std::string, std::string> > ret;
	ret.push_back(std::make_pair("<__app__>", fields_.app));
	ret.push_back(std::make_pair("<__theme__>", fields_.id));
	return ret;
}




const std::string topencv_header::windows_prj_alias = "windows_prj";

void topencv_header::app_complete_paths()
{
	const std::string& src2_path = ::alias_2_path(paths_, ttask::src2_alias);

	paths_.insert(std::make_pair(windows_prj_alias, src2_path + "/projectfiles/windows-prj"));
}

std::vector<std::pair<std::string, std::string> > topencv_header::app_get_replace(const tsubtask& subtask)
{
	return std::vector<std::pair<std::string, std::string> >();
}